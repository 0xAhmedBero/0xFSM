
import {
  NodeDefinition,
  DraggableNode,
} from './types/NodeDefinition'
import {
  FUNC_PREFIX,
  EVENT_PREFIX,
  GraphData,
  FunctionScope,
  EventScope
} from '../pages/UI/GraphContext'
import { isValidLuaIdentifier } from './nodes/utils/validationUtils'; 

// Interface for ManifestSettings (passed from CodeGenerationModal)
interface ManifestSettings {
  resourceName: string
  author: string
  version: string
  description: string
  fxVersion: string
  games: string[]
  // User defined scripts (relative paths, e.g., 'client/cl_custom.lua')
  clientScripts: string[]
  serverScripts: string[]
  sharedScripts: string[]
  dependencies?: string
  exports?: string
  uiPage?: string
  // List of generated files passed from the modal for conditional inclusion
  generatedFiles?: string[]
}

// Default filenames for generated code
const SHARED_FUNCTIONS_FILENAME = 'shared/sh_functions.lua'
const CLIENT_FUNCTIONS_FILENAME = 'client/cl_functions.lua'
const SERVER_FUNCTIONS_FILENAME = 'server/sv_functions.lua'
const CLIENT_EVENTS_FILENAME = 'client/cl_events.lua'
const SERVER_EVENTS_FILENAME = 'server/sv_events.lua'

// Helper function for string splitting (avoids polluting global namespace)
const STRING_SPLIT_HELPER_NAME = '__FSM_Internal_StringSplit'
const STRING_SPLIT_HELPER_CODE = `
local function ${STRING_SPLIT_HELPER_NAME}(inputstr, sep, limit)
    if sep == nil then sep = "%s" end
    if sep == '' then -- Split into characters
        local result = {}
        local n = 0
        for i = 1, #inputstr do
            if limit and n >= limit then break end
            n = n + 1
            result[n] = string.sub(inputstr, i, i)
        end
        return result
    end

    local t = {}
    local i = 1
    local n = 0 -- Track number of elements added

    while true do
        if limit and n >= limit then
            -- If limit is reached, add the rest of the string as the last element
            if i <= #inputstr then
                t[n + 1] = string.sub(inputstr, i)
            end
            break
        end

        local start_idx, end_idx = string.find(inputstr, sep, i, true) -- Use plain find

        if start_idx then
            n = n + 1
            t[n] = string.sub(inputstr, i, start_idx - 1)
            i = end_idx + 1
        else
            -- No more separators found, add the rest of the string
            n = n + 1
            t[n] = string.sub(inputstr, i)
            break
        end
    end
    return t
end
`

let stringSplitHelperIncluded = false // Track if helper is added to avoid duplicates
let ludbCommentIncluded = false // Track if ludb comment is added

export class CodeGeneratorService {
  // Reset helper inclusion flag before generating a set of files
  static resetHelperFlags () {
    stringSplitHelperIncluded = false
    ludbCommentIncluded = false // Reset ludb comment flag
  }

  // --- Manifest Generation ---
  static generateManifestCode (
    settings: ManifestSettings,
    allGraphs: Record<string, GraphData>
  ): string {
    // ... (Manifest generation logic remains unchanged) ...
    let manifestCode = `-- fxmanifest.lua for ${
      settings.resourceName
    }\n-- Generated by 0xFSM | ${new Date().toLocaleString()}\n\n`
    manifestCode += `fx_version '${settings.fxVersion || 'cerulean'}'\ngame '${
      settings.games[0] || 'gta5'
    }'\n\n`
    manifestCode += `resource_manifest_version '44febabe-d386-4d18-afbe-5e627f4af937'\n\n`
    manifestCode += `name '${settings.resourceName}'\nversion '${settings.version}'\nauthor '${settings.author}'\ndescription '${settings.description}'\n\n`

    const generatedFiles = settings.generatedFiles || [] // Files generated by this service
    const userClientScripts = settings.clientScripts || []
    const userServerScripts = settings.serverScripts || []
    const userSharedScripts = settings.sharedScripts || [] // Manually entered by user

    // Check which generated files actually exist to include them
    const includeSharedFuncs = generatedFiles.includes(
      SHARED_FUNCTIONS_FILENAME
    )
    const includeClientFuncs = generatedFiles.includes(
      CLIENT_FUNCTIONS_FILENAME
    )
    const includeServerFuncs = generatedFiles.includes(
      SERVER_FUNCTIONS_FILENAME
    )
    const includeClientEvents = generatedFiles.includes(CLIENT_EVENTS_FILENAME)
    const includeServerEvents = generatedFiles.includes(SERVER_EVENTS_FILENAME)

    // Check for 0xludb-fivem usage to add dependency suggestion/auto-add
    let usesLudb = false
    for (const key in allGraphs) {
      if (allGraphs[key]?.nodes?.some(n => n.id.startsWith('ludb'))) {
        usesLudb = true
        break
      }
    }

    // Dependency management
    let dependencies = (settings.dependencies || '')
      .split(',')
      .map(d => d.trim())
      .filter(d => d)
    if (usesLudb && !dependencies.includes('0xludb-fivem')) {
      dependencies.push('0xludb-fivem') // Add dependency if used and not present
      manifestCode +=
        "-- Dependency '0xludb-fivem' automatically added due to Ludb node usage.\n"
    }
    if (dependencies.length > 0) {
      manifestCode += '-- Dependencies\n'
      manifestCode +=
        dependencies.map(dep => `dependency '${dep}'`).join('\n') + '\n\n'
    }

    // Combine generated and user scripts for each category
    const sharedScriptsToInclude = [
      ...(includeSharedFuncs ? [SHARED_FUNCTIONS_FILENAME] : []),
      ...userSharedScripts
    ].map(s => `'${s.replace(/\\/g, '/')}'`) // Ensure forward slashes and quotes

    const clientScriptsToInclude = [
      ...(includeClientFuncs ? [CLIENT_FUNCTIONS_FILENAME] : []),
      ...(includeClientEvents ? [CLIENT_EVENTS_FILENAME] : []),
      ...userClientScripts
    ].map(s => `'${s.replace(/\\/g, '/')}'`)

    const serverScriptsToInclude = [
      ...(includeServerFuncs ? [SERVER_FUNCTIONS_FILENAME] : []),
      ...(includeServerEvents ? [SERVER_EVENTS_FILENAME] : []),
      ...userServerScripts
    ].map(s => `'${s.replace(/\\/g, '/')}'`)

    // Add script sections only if they contain scripts
    if (sharedScriptsToInclude.length > 0) {
      manifestCode += `shared_scripts {\n    ${sharedScriptsToInclude.join(
        ',\n    '
      )}\n}\n\n`
    }
    if (clientScriptsToInclude.length > 0) {
      manifestCode += `client_scripts {\n    ${clientScriptsToInclude.join(
        ',\n    '
      )}\n}\n\n`
    }
    if (serverScriptsToInclude.length > 0) {
      manifestCode += `server_scripts {\n    ${serverScriptsToInclude.join(
        ',\n    '
      )}\n}\n\n`
    }

    // UI Page and Files
    if (settings.uiPage?.trim()) {
      const uiPage = settings.uiPage.trim().replace(/\\/g, '/')
      manifestCode += `ui_page '${uiPage}'\n`
      const uiFolderMatch = uiPage.match(/^([a-zA-Z0-9_.\/-]+)\//)
      const baseUiFolder = uiFolderMatch
        ? uiFolderMatch[1]
        : uiPage.includes('/')
        ? uiPage.split('/')[0]
        : 'html'
      manifestCode += 'files {\n'
      manifestCode += `    '${uiPage}',\n`
      manifestCode += `    '${baseUiFolder}/**/*', -- Include related UI assets\n`
      manifestCode += '}\n\n'
    }

    // Exports
    if (settings.exports?.trim()) {
      manifestCode += '-- Exports\n'
      settings.exports
        .split(',')
        .map(exp => exp.trim())
        .filter(exp => exp)
        .forEach(exp => {
          const lowerExp = exp.toLowerCase()
          if (
            lowerExp.startsWith('export ') ||
            lowerExp.startsWith('client_export ') ||
            lowerExp.startsWith('server_export ')
          ) {
            manifestCode += `${exp}\n`
          } else {
            if (/^['"]?[a-zA-Z_][a-zA-Z0-9_]*['"]?$/.test(exp)) {
              manifestCode += `export ${exp}\n`
              manifestCode += `-- NOTE: Assuming 'export ${exp}' - verify if client_ or server_ needed.\n`
            } else {
              manifestCode += `-- ERROR: Invalid export format: ${exp}\n`
            }
          }
        })
      manifestCode += '\n'
    }

    return manifestCode.trimEnd() + '\n'
  }

  // --- User File Generation ---
  static generateLuaCodeForFile (
    fileName: string,
    fileType: 'client' | 'server',
    fileNodes: DraggableNode[]
  ): string {
    let code = `-- ${fileType}/${fileName}.lua\n-- Generated by 0xFSM | ${new Date().toLocaleString()}\n`
    let needsSplitHelper = false
    let needsLudb = false

    if (fileNodes?.some(n => n.id === 'stringSplit')) {
      needsSplitHelper = true
    }
    if (fileNodes?.some(n => n.id.startsWith('ludb'))) {
      needsLudb = true
    }

    if (needsLudb && !ludbCommentIncluded) {
      code += `\nlocal ludb = exports['0xludb-fivem']\n\n`
      ludbCommentIncluded = true
    } else if (needsLudb) {
      code += `local ludb = exports['0xludb-fivem'] -- Assuming already declared\n\n`
    } else {
      code += '\n' // Add newline if no ludb needed
    }

    if (needsSplitHelper && !stringSplitHelperIncluded) {
      code += STRING_SPLIT_HELPER_CODE + '\n'
      stringSplitHelperIncluded = true
    }

    if (fileType === 'client') code += '\n\n'

    code += '-- >>>>>> Generated File Logic Start >>>>>>\n\n'

    const declaredVariables = new Set<string>()
    let currentIndent = 0
    let commandRegistrations = '' // Separate command registrations
    let mainLogic = ''

    if (fileNodes && fileNodes.length > 0) {
      for (const node of fileNodes) {
        const nodeCodeResult = this.generateNodeCode(
          node,
          declaredVariables,
          fileType,
          false, // false = not inside function/event block
          currentIndent
        )
        if (node.id === 'registerCommand') {
          if (nodeCodeResult.code.trim()) {
            commandRegistrations += nodeCodeResult.code + '\n\n' // Group commands
          }
        } else {
          if (nodeCodeResult.code.trim()) {
            // Add newline before non-control-flow nodes if needed
            if (
              mainLogic.trimEnd().length > 0 &&
              !/^\s*(end|else)\b/.test(nodeCodeResult.code.trim()) &&
              !mainLogic.trimEnd().endsWith('\n')
            ) {
              mainLogic += '\n'
            }
            mainLogic += nodeCodeResult.code + '\n'
          }
        }
        currentIndent = nodeCodeResult.newIndent
      }
      // Close any remaining open blocks (should ideally be 0)
      while (currentIndent > 0) {
        currentIndent--
        mainLogic +=
          ' '.repeat(currentIndent * 4) + 'end -- Auto-closed block\n'
      }
    } else {
      mainLogic += '-- Graph for this file is empty.\n'
    }

    // Combine sections
    if (commandRegistrations) {
      code += '-- >>>>>> Command Registrations Start >>>>>>\n\n'
      code += commandRegistrations
      code += '-- <<<<<< Command Registrations End <<<<<<\n\n'
    }
    code += mainLogic.trimEnd() // Append main logic

    code += '\n\n-- <<<<<< Generated File Logic End <<<<<<\n'
    return code + '\n'
  }

  // --- Function File Generation ---
  static generateFunctionFileCode (
    scope: FunctionScope,
    allGraphs: Record<string, GraphData>
  ): { filename: string; code: string } | null {
    const scopeFilename =
      scope === 'client'
        ? CLIENT_FUNCTIONS_FILENAME
        : scope === 'server'
        ? SERVER_FUNCTIONS_FILENAME
        : SHARED_FUNCTIONS_FILENAME
    let functionBodies = ''
    let functionsFound = false
    let needsSplitHelper = false
    let needsLudb = false

    for (const graphKey in allGraphs) {
      if (graphKey.startsWith(FUNC_PREFIX)) {
        const funcGraphData = allGraphs[graphKey]
        if (
          funcGraphData &&
          funcGraphData.scope === scope &&
          funcGraphData.parameters !== undefined
        ) {
          const funcName = graphKey.substring(FUNC_PREFIX.length)
          const funcCode = this.generateFunctionDefinition(
            funcName,
            funcGraphData.nodes || [],
            funcGraphData.parameters || [],
            scope
          )
          functionBodies += funcCode
          functionBodies += '\n-- ----------------------------------------\n\n'
          functionsFound = true
          if (funcGraphData.nodes?.some(n => n.id === 'stringSplit'))
            needsSplitHelper = true
          if (funcGraphData.nodes?.some(n => n.id.startsWith('ludb')))
            needsLudb = true
        }
      }
    }

    if (!functionsFound) return null // No functions defined for this scope

    let code = `-- ${scopeFilename}\n-- Generated ${scope} functions by 0xFSM | ${new Date().toLocaleString()}\n`

    if (needsLudb && !ludbCommentIncluded) {
      code += `\nlocal ludb = exports['0xludb-fivem']\n\n`
      ludbCommentIncluded = true
    } else if (needsLudb) {
      code += `local ludb = exports['0xludb-fivem'] -- Assuming already declared\n\n`
    } else {
      code += '\n'
    }

    if (needsSplitHelper && !stringSplitHelperIncluded) {
      code += STRING_SPLIT_HELPER_CODE + '\n'
      stringSplitHelperIncluded = true
    }

    if (scope === 'client') code += '\n\n'
    code += '-- ================== FUNCTIONS ==================\n\n'
    code += functionBodies
    code += '-- ================ END FUNCTIONS ================\n'
    return { filename: scopeFilename, code: code.trimEnd() + '\n' }
  }

  // --- Event File Generation ---
  static generateEventFileCode (
    scope: EventScope,
    allGraphs: Record<string, GraphData>
  ): { filename: string; code: string } | null {
    const scopeFilename =
      scope === 'client' ? CLIENT_EVENTS_FILENAME : SERVER_EVENTS_FILENAME
    let eventHandlerBodies = ''
    let eventsFound = false
    let needsSplitHelper = false
    let needsLudb = false

    for (const graphKey in allGraphs) {
      if (graphKey.startsWith(EVENT_PREFIX)) {
        const eventGraphData = allGraphs[graphKey]
        if (
          eventGraphData &&
          eventGraphData.scope === scope &&
          eventGraphData.argumentNames !== undefined
        ) {
          const eventName = graphKey.substring(EVENT_PREFIX.length)
          const handlerCode = this.generateEventHandlerDefinition(
            eventName,
            eventGraphData.nodes || [],
            eventGraphData.argumentNames || [],
            scope
          )
          eventHandlerBodies += handlerCode
          eventHandlerBodies +=
            '\n-- --------------------------------------------\n\n'
          eventsFound = true
          if (eventGraphData.nodes?.some(n => n.id === 'stringSplit'))
            needsSplitHelper = true
          if (eventGraphData.nodes?.some(n => n.id.startsWith('ludb')))
            needsLudb = true
        }
      }
    }

    if (!eventsFound) return null // No events defined for this scope

    let code = `-- ${scopeFilename}\n-- Generated ${scope} event handlers by 0xFSM | ${new Date().toLocaleString()}\n`

    if (needsLudb && !ludbCommentIncluded) {
      code += `\nlocal ludb = exports['0xludb-fivem']\n\n`
      ludbCommentIncluded = true
    } else if (needsLudb) {
      code += `local ludb = exports['0xludb-fivem'] -- Assuming already declared\n\n`
    } else {
      code += '\n'
    }

    if (needsSplitHelper && !stringSplitHelperIncluded) {
      code += STRING_SPLIT_HELPER_CODE + '\n'
      stringSplitHelperIncluded = true
    }

    if (scope === 'client') code += '\n\n'
    code += '-- ================== EVENT HANDLERS ==================\n\n'
    code += eventHandlerBodies
    code += '-- ================ END EVENT HANDLERS ================\n'
    return { filename: scopeFilename, code: code.trimEnd() + '\n' }
  }

  // --- Function Definition Generation ---
  private static generateFunctionDefinition (
    /* ... no changes ... */
    funcName: string,
    nodes: DraggableNode[],
    parameters: string[],
    scope: FunctionScope
  ): string {
    const paramsString = parameters.join(', ')
    let funcCode = `function ${funcName}(${paramsString})\n`
    const declaredVariables = new Set<string>(parameters)
    let currentIndent = 1
    if (nodes && nodes.length > 0) {
      for (const node of nodes) {
        const nodeCodeResult = this.generateNodeCode(
          node,
          declaredVariables,
          scope,
          true,
          currentIndent
        )
        if (nodeCodeResult.code.trim()) {
          if (
            funcCode.trimEnd().length > 0 &&
            !/^\s*(end|else)\b/.test(nodeCodeResult.code.trim()) &&
            !funcCode.trimEnd().endsWith('\n')
          )
            funcCode += '\n'
          funcCode += nodeCodeResult.code + '\n'
        }
        currentIndent = nodeCodeResult.newIndent
      }
      while (currentIndent > 1) {
        currentIndent--
        funcCode += ' '.repeat(currentIndent * 4) + 'end -- Auto-closed block\n'
      }
    } else {
      funcCode += '    -- Function graph is empty\n'
    }
    funcCode = funcCode.trimEnd() + '\nend'
    return funcCode
  }

  // --- Event Handler Definition Generation ---
  private static generateEventHandlerDefinition (
    /* ... no changes ... */
    eventName: string,
    nodes: DraggableNode[],
    argumentNames: string[],
    scope: EventScope
  ): string {
    const argsString = argumentNames.join(', ')
    let handlerCode = `RegisterNetEvent('${eventName}', function(${argsString})\n`
    const declaredVariables = new Set<string>(argumentNames)
    if (scope === 'server') declaredVariables.add('source')
    let currentIndent = 1
    if (nodes && nodes.length > 0) {
      for (const node of nodes) {
        const nodeCodeResult = this.generateNodeCode(
          node,
          declaredVariables,
          scope,
          true,
          currentIndent
        )
        if (nodeCodeResult.code.trim()) {
          if (
            handlerCode.trimEnd().length > 0 &&
            !/^\s*(end|else)\b/.test(nodeCodeResult.code.trim()) &&
            !handlerCode.trimEnd().endsWith('\n')
          )
            handlerCode += '\n'
          handlerCode += nodeCodeResult.code + '\n'
        }
        currentIndent = nodeCodeResult.newIndent
      }
      while (currentIndent > 1) {
        currentIndent--
        handlerCode +=
          ' '.repeat(currentIndent * 4) + 'end -- Auto-closed block\n'
      }
    } else {
      handlerCode += '    -- Event handler graph is empty\n'
    }
    handlerCode = handlerCode.trimEnd() + '\nend)'
    return handlerCode
  }

  // --- Core Node Code Generation ---
  private static generateNodeCode (
    node: DraggableNode,
    declaredVariables: Set<string>,
    fileType: 'client' | 'server' | 'shared',
    isInsideBlock: boolean, // True if inside function or event handler
    currentIndent: number
  ): { code: string; newIndent: number } {
    let generatedCode = ''
    let comment = `-- ${node.label || node.id} (${node.runtimeId})`
    let indentAdjustment = 0
    let preIndentAdjustment = 0
    const indentString = ' '.repeat(currentIndent * 4) // Base indent for this node

    try {
      switch (node.id) {
        // <<< Existing Cases >>>
        case 'registerCommand':
          generatedCode = this.generateRegisterCommandCode(node)
          break
        case 'print':
          generatedCode = this.generatePrintNodeCode(node, fileType)
          break
        case 'variable':
          generatedCode = this.generateVariableNodeCode(
            node,
            declaredVariables,
            isInsideBlock
          )
          break
        case 'readVariable':
          comment = `-- Read Var: '${node.variableName}'`
          break
        case 'math':
          generatedCode = this.generateMathNodeCode(
            node,
            declaredVariables,
            isInsideBlock
          )
          break
        case 'concatStrings':
          generatedCode = this.generateConcatStringsNodeCode(
            node,
            declaredVariables,
            isInsideBlock
          )
          break
        case 'wait':
          generatedCode = this.generateWaitNodeCode(node)
          break
        case 'callFunction':
          generatedCode = this.generateCallFunctionNodeCode(
            node,
            declaredVariables,
            isInsideBlock
          )
          break
        case 'return':
          generatedCode = this.generateReturnNodeCode(node)
          break
        case 'ifCondition':
          generatedCode = this.generateIfConditionCode(node)
          indentAdjustment = 1
          break
        case 'elseCondition':
          preIndentAdjustment = -1
          generatedCode = 'else'
          indentAdjustment = 1
          break
        case 'endIf':
          preIndentAdjustment = -1
          generatedCode = 'end'
          break
        case 'whileCondition':
          generatedCode = this.generateWhileConditionCode(node)
          indentAdjustment = 1
          break
        case 'endWhile':
          preIndentAdjustment = -1
          generatedCode = 'end'
          break
        case 'forLoopNumeric':
          generatedCode = this.generateForLoopNumericCode(
            node,
            declaredVariables
          )
          indentAdjustment = 1
          break
        case 'endFor':
          preIndentAdjustment = -1
          generatedCode = 'end'
          break
        case 'forLoopGeneric':
          generatedCode = this.generateForLoopGenericCode(
            node,
            declaredVariables
          )
          indentAdjustment = 1
          break
        case 'endForGeneric':
          preIndentAdjustment = -1
          generatedCode = 'end'
          break
        case 'break':
          generatedCode = 'break'
          break // Allow break anywhere syntactically
        case 'triggerServerEvent':
          generatedCode = this.generateTriggerServerEventCode(node)
          break
        case 'triggerClientEvent':
          generatedCode = this.generateTriggerClientEventCode(node)
          break
        case 'createTable':
          generatedCode = this.generateCreateTableCode(
            node,
            declaredVariables,
            isInsideBlock
          )
          break
        case 'setTableValue':
          generatedCode = this.generateSetTableValueCode(node)
          break
        case 'getTableValue':
          generatedCode = this.generateGetTableValueCode(
            node,
            declaredVariables,
            isInsideBlock
          )
          break
        case 'callNative':
          generatedCode = this.generateCallNativeCode(
            node,
            declaredVariables,
            isInsideBlock
          )
          break
        case 'vector3':
          generatedCode = this.generateVector3Code(
            node,
            declaredVariables,
            isInsideBlock
          )
          break
        case 'json':
          generatedCode = this.generateJsonCode(
            node,
            declaredVariables,
            isInsideBlock,
            indentString
          )
          break
        case 'insertIntoTable':
          generatedCode = this.generateInsertIntoTableCode(node)
          break
        case 'getTableLength':
          generatedCode = this.generateGetTableLengthCode(
            node,
            declaredVariables,
            isInsideBlock
          )
          break
        case 'stringFormat':
          generatedCode = this.generateStringFormatCode(
            node,
            declaredVariables,
            isInsideBlock
          )
          break
        case 'stringSplit':
          generatedCode = this.generateStringSplitCode(
            node,
            declaredVariables,
            isInsideBlock
          )
          break
        case 'typeCheck':
          generatedCode = this.generateTypeCheckCode(
            node,
            declaredVariables,
            isInsideBlock
          )
          break
        case 'toString':
          generatedCode = this.generateToStringCode(
            node,
            declaredVariables,
            isInsideBlock
          )
          break
        case 'toNumber':
          generatedCode = this.generateToNumberCode(
            node,
            declaredVariables,
            isInsideBlock
          )
          break
        case 'stringSubstring':
          generatedCode = this.generateStringSubstringCode(
            node,
            declaredVariables,
            isInsideBlock
          )
          break
        case 'stringLength':
          generatedCode = this.generateStringLengthCode(
            node,
            declaredVariables,
            isInsideBlock
          )
          break
        case 'stringFind':
          generatedCode = this.generateStringFindCode(
            node,
            declaredVariables,
            isInsideBlock
          )
          break
        case 'stringReplace':
          generatedCode = this.generateStringReplaceCode(
            node,
            declaredVariables,
            isInsideBlock
          )
          break
        case 'stringCase':
          generatedCode = this.generateStringCaseCode(
            node,
            declaredVariables,
            isInsideBlock
          )
          break
        case 'mathAdvanced':
          generatedCode = this.generateMathAdvancedCode(
            node,
            declaredVariables,
            isInsideBlock
          )
          break
        case 'tableRemove':
          generatedCode = this.generateTableRemoveCode(node)
          break
        case 'tableSort':
          generatedCode = this.generateTableSortCode(node)
          break

        // --- Ludb Nodes ---
        case 'ludbSaveGlobal':
          generatedCode = this.generateLudbSaveCode(node, true)
          break
        case 'ludbSaveLocal':
          generatedCode = this.generateLudbSaveCode(node, false)
          break
        case 'ludbRetrieveGlobal':
          generatedCode = this.generateLudbRetrieveCode(
            node,
            declaredVariables,
            isInsideBlock,
            true
          )
          break
        case 'ludbRetrieveLocal':
          generatedCode = this.generateLudbRetrieveCode(
            node,
            declaredVariables,
            isInsideBlock,
            false
          )
          break
        case 'ludbDeleteGlobal':
          generatedCode = this.generateLudbDeleteCode(node, true)
          break
        case 'ludbDeleteLocal':
          generatedCode = this.generateLudbDeleteCode(node, false)
          break

        default:
          comment = `-- Unknown Node Type: ${node.id}`
          break
      }
    } catch (error: any) {
      comment = `-- GEN_ERROR for ${node.id}: ${error.message}`
    }

    // Apply indentation and combine code/comment (remains same)
    const effectiveIndent = Math.max(0, currentIndent + preIndentAdjustment)
    const currentIndentStr = ' '.repeat(effectiveIndent * 4)
    let finalCode = ''
    const hasGeneratedCode = (generatedCode?.trim() ?? '') !== ''
    const addComment =
      !hasGeneratedCode ||
      comment.startsWith('-- GEN_ERROR') ||
      comment.startsWith('-- Unknown') ||
      comment.startsWith('-- Return ignored') ||
      comment.startsWith('-- Read Var') ||
      comment !== `-- ${node.label || node.id} (${node.runtimeId})`
    if (addComment) {
      finalCode += currentIndentStr + comment + '\n'
    }
    if (hasGeneratedCode) {
      finalCode +=
        generatedCode
          .split('\n')
          .map(line => (line.trim() ? currentIndentStr + line : ''))
          .join('\n')
          .trimEnd() + '\n'
    }
    const newIndent = Math.max(0, effectiveIndent + indentAdjustment)
    return { code: finalCode.trimEnd(), newIndent: newIndent }
  }

  // --- Node Specific Generators ---

  // Helper to get key/value expressions for DB nodes
  private static getKeyExpression (node: NodeDefinition): string {
    const keyType = node.keyType || 'literal'
    const keyValue = node.keyValue ?? ''
    if (keyType === 'variable') {
      return keyValue || 'nil --[[ ERROR: Missing Key Var ]]'
    } else {
      // Keys are typically strings for ludb
      return this.formatLiteralForLua(keyValue)
    }
  }

  private static getValueExpression (node: NodeDefinition): string {
    const valueType = node.valueType || 'literal'
    const valueSource = node.valueSource ?? ''
    if (valueType === 'variable') {
      return valueSource || 'nil --[[ ERROR: Missing Value Var ]]'
    } else {
      return this.formatLiteralForLua(valueSource)
    }
  }

  // Ludb Generators
  private static generateLudbSaveCode (
    node: NodeDefinition,
    isGlobal: boolean
  ): string {
    const keyExpr = this.getKeyExpression(node)
    const valueExpr = this.getValueExpression(node)
    const funcName = isGlobal ? 'ludb:saveGlobal' : 'ludb:save'
    return `${funcName}(${keyExpr}, ${valueExpr})`
  }

  private static generateLudbRetrieveCode (
    node: NodeDefinition,
    declaredVariables: Set<string>,
    isInsideBlock: boolean,
    isGlobal: boolean
  ): string {
    const resultVar = node.resultVariable || 'retrievedValue'
    const keyExpr = this.getKeyExpression(node)
    const defaultValueExpr = this.formatLiteralForLua(node.defaultValue ?? null) // Default to nil
    const funcName = isGlobal ? 'ludb:retrieveGlobal' : 'ludb:retrieve'

    if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(resultVar)) {
      return `-- ERROR: Invalid result variable name: ${resultVar}`
    }

    const prefix =
      isInsideBlock && !declaredVariables.has(resultVar) ? 'local ' : ''
    if (isInsideBlock && !declaredVariables.has(resultVar))
      declaredVariables.add(resultVar)

    // ludb retrieve functions don't directly take a default value like this.
    // We need to simulate the default value check after retrieval.
    const retrieveLine = `${prefix}${resultVar} = ${funcName}(${keyExpr})`
    const defaultCheckLine = `if ${resultVar} == nil then\n    ${resultVar} = ${defaultValueExpr}\nend`

    return `${retrieveLine}\n${defaultCheckLine}`
  }

  private static generateLudbDeleteCode (
    node: NodeDefinition,
    isGlobal: boolean
  ): string {
    const keyExpr = this.getKeyExpression(node)
    const funcName = isGlobal ? 'ludb:deleteGlobal' : 'ludb:delete'
    return `${funcName}(${keyExpr})`
  }

  // <<< Other existing node generators remain unchanged >>>
  private static generateRegisterCommandCode = (
    node: NodeDefinition
  ): string => {
    const command = node.commandName?.trim()
    const targetFunc = node.functionName?.trim()
    const restricted = node.restricted ?? false
    if (!command) return `-- ERROR: RegisterCommand - Missing command name.`
    if (!targetFunc)
      return `-- ERROR: RegisterCommand('${command}') - Missing target function name.`
    const commandLiteral = this.formatLiteralForLua(command)
    const handlerFunction = `function(source, args, rawCommand)\n    ${targetFunc}(source, args, rawCommand)\nend`
    return `RegisterCommand(${commandLiteral}, ${handlerFunction}, ${restricted})`
  }
  private static generatePrintNodeCode = (
    node: NodeDefinition,
    fileType: 'client' | 'server' | 'shared'
  ): string => {
    const useVar = node.useVariableForMessage ?? false
    const varName = node.messageVariable
    const message = node.message ?? ''
    const useConsole = node.printToConsole ?? true
    let valueToPrint: string
    if (useVar && varName) valueToPrint = `tostring(${varName})`
    else valueToPrint = this.formatLiteralForLua(message)
    if (useConsole) return `print(${valueToPrint})`
    else {
      if (fileType === 'client' || fileType === 'shared')
        return `TriggerEvent('chat:addMessage', { args = { '[${
          node.label || 'FSM'
        }]', ${valueToPrint} } })`
      else
        return `print("SERVER: [${
          node.label || 'FSM'
        }] " .. tostring(${valueToPrint}))`
    }
  }
  private static generateVariableNodeCode = (
    node: NodeDefinition,
    declaredVariables: Set<string>,
    isInsideBlock: boolean
  ): string => {
    const varName = node.name?.trim()
    if (!varName || !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(varName))
      return `-- ERROR: Invalid variable name: ${varName}`
    const value = node.value
    const dataType = node.dataType || 'string'
    const varType = node.varType || 'local'
    let prefix: string = ''
    if (varType === 'local') {
      if (isInsideBlock && !declaredVariables.has(varName)) {
        prefix = 'local '
        declaredVariables.add(varName)
      } else if (!isInsideBlock && !declaredVariables.has(varName)) {
        prefix = 'local '
        declaredVariables.add(varName)
      } else {
        prefix = ''
      }
    } else {
      prefix = '_G.'
    }
    let luaValue: string
    switch (dataType) {
      case 'number':
        const num = Number(value)
        luaValue = isNaN(num) ? '0 --[[ WARN: Invalid number ]]' : String(num)
        break
      case 'boolean':
        luaValue = String(value).toLowerCase() === 'true' ? 'true' : 'false'
        break
      case 'nil':
        luaValue = 'nil'
        break
      case 'variable':
        if (
          !value ||
          typeof value !== 'string' ||
          !isValidLuaIdentifier(value) // Make sure isValidLuaIdentifier is available
        ) {
          luaValue = 'nil --[[ ERROR: Invalid source variable name ]]'
        } else {
          luaValue = value
        }
        break
      case 'string':
      default:
        luaValue = this.formatLiteralForLua(value)
        break
    }
    if (prefix === '_G.') return `${prefix}${varName} = ${luaValue}`
    else return `${prefix}${varName} = ${luaValue}`
  }
  private static generateMathNodeCode = (
    node: NodeDefinition,
    declaredVariables: Set<string>,
    isInsideBlock: boolean
  ): string => {
    const resultVar = node.resultVariable || 'mathResult'
    const opMap: any = { add: '+', subtract: '-', multiply: '*', divide: '/' }
    const op = opMap[node.operation || 'add'] || '+'
    const v1 = node.useVariableForValue1
      ? node.value1Variable || '0'
      : this.formatLiteralForLua(node.value1 ?? 0)
    const v2 = node.useVariableForValue2
      ? node.value2Variable || '0'
      : this.formatLiteralForLua(node.value2 ?? 0)
    const expr = `tonumber(${v1}) ${op} tonumber(${v2})`
    const prefix =
      isInsideBlock && !declaredVariables.has(resultVar) ? 'local ' : ''
    if (isInsideBlock && !declaredVariables.has(resultVar))
      declaredVariables.add(resultVar)
    return `${prefix}${resultVar} = ${expr}`
  }
  private static generateConcatStringsNodeCode = (
    node: NodeDefinition,
    declaredVariables: Set<string>,
    isInsideBlock: boolean
  ): string => {
    const resultVar = node.resultVariable || 'concatResult'
    const s1 = node.useVariableForString1
      ? `tostring(${node.string1Variable || '""'})`
      : this.formatLiteralForLua(node.string1 ?? '')
    const s2 = node.useVariableForString2
      ? `tostring(${node.string2Variable || '""'})`
      : this.formatLiteralForLua(node.string2 ?? '')
    const expr = `${s1} .. ${s2}`
    const prefix =
      isInsideBlock && !declaredVariables.has(resultVar) ? 'local ' : ''
    if (isInsideBlock && !declaredVariables.has(resultVar))
      declaredVariables.add(resultVar)
    return `${prefix}${resultVar} = ${expr}`
  }
  private static generateWaitNodeCode = (node: NodeDefinition): string => {
    const dur = node.useVariableForDuration
      ? `tonumber(${node.durationVariable || '0'})`
      : String(Math.max(0, Number(node.duration)) || 0)
    return `Wait(math.max(0, math.floor(${dur})))`
  }
  private static generateReturnNodeCode = (node: NodeDefinition): string => {
    let valSrc
    if (node.useVariableForResult && node.returnVariable) {
      valSrc = node.returnVariable
    } else {
      valSrc = this.formatLiteralForLua(node.returnValue)
    }
    return `return ${valSrc}`
  }
  private static generateCallFunctionNodeCode = (
    node: NodeDefinition,
    declaredVariables: Set<string>,
    isInsideBlock: boolean
  ): string => {
    const funcName = node.functionName
    if (!funcName) return '-- ERROR: No function name specified.'
    const resultVar = node.resultVariable || 'funcResult'
    const argsStr = (node.argumentSources || [])
      .map(arg =>
        arg.type === 'variable'
          ? arg.value || 'nil'
          : this.formatLiteralForLua(arg.value)
      )
      .join(', ')
    const prefix =
      isInsideBlock && !declaredVariables.has(resultVar) ? 'local ' : ''
    if (isInsideBlock && !declaredVariables.has(resultVar))
      declaredVariables.add(resultVar)
    return `${prefix}${resultVar} = ${funcName}(${argsStr})`
  }
  private static generateIfConditionCode = (node: NodeDefinition): string => {
    let lhs: string
    let rhs: string | null = null
    if (node.conditionLhsType === 'variable')
      lhs = node.conditionLhsValue || 'nil'
    else lhs = this.formatLiteralForLua(node.conditionLhsValue)
    const operator = node.conditionOperator || '=='
    const isUnary = ['is true', 'is false', 'is nil', 'is not nil'].includes(
      operator
    )
    if (!isUnary) {
      if (node.conditionRhsType === 'variable')
        rhs = node.conditionRhsValue || 'nil'
      else rhs = this.formatLiteralForLua(node.conditionRhsValue)
    }
    switch (operator) {
      case 'is true':
        return `if ${lhs} then`
      case 'is false':
        return `if not ${lhs} then`
      case 'is nil':
        return `if ${lhs} == nil then`
      case 'is not nil':
        return `if ${lhs} ~= nil then`
      case '==':
        return `if ${lhs} == ${rhs} then`
      case '~=':
        return `if ${lhs} ~= ${rhs} then`
      case '>':
        return `if tonumber(${lhs}) > tonumber(${rhs}) then`
      case '<':
        return `if tonumber(${lhs}) < tonumber(${rhs}) then`
      case '>=':
        return `if tonumber(${lhs}) >= tonumber(${rhs}) then`
      case '<=':
        return `if tonumber(${lhs}) <= tonumber(${rhs}) then`
      default:
        return `-- ERROR: Invalid op\nif false then`
    }
  }
  private static generateWhileConditionCode = (
    node: NodeDefinition
  ): string => {
    let lhs: string
    let rhs: string | null = null
    if (node.conditionLhsType === 'variable')
      lhs = node.conditionLhsValue || 'nil'
    else lhs = this.formatLiteralForLua(node.conditionLhsValue)
    const operator = node.conditionOperator || '=='
    const isUnary = ['is true', 'is false', 'is nil', 'is not nil'].includes(
      operator
    )
    if (!isUnary) {
      if (node.conditionRhsType === 'variable')
        rhs = node.conditionRhsValue || 'nil'
      else rhs = this.formatLiteralForLua(node.conditionRhsValue)
    }
    switch (operator) {
      case 'is true':
        return `while ${lhs} do`
      case 'is false':
        return `while not ${lhs} do`
      case 'is nil':
        return `while ${lhs} == nil do`
      case 'is not nil':
        return `while ${lhs} ~= nil do`
      case '==':
        return `while ${lhs} == ${rhs} do`
      case '~=':
        return `while ${lhs} ~= ${rhs} do`
      case '>':
        return `while tonumber(${lhs}) > tonumber(${rhs}) do`
      case '<':
        return `while tonumber(${lhs}) < tonumber(${rhs}) do`
      case '>=':
        return `while tonumber(${lhs}) >= tonumber(${rhs}) do`
      case '<=':
        return `while tonumber(${lhs}) <= tonumber(${rhs}) do`
      default:
        return `-- ERROR: Invalid op\nwhile false do`
    }
  }
  private static generateForLoopNumericCode = (
    node: NodeDefinition,
    declaredVariables: Set<string>
  ): string => {
    const controlVar = node.controlVariable || 'i'
    if (!controlVar || !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(controlVar))
      return `-- ERROR: Invalid control variable: ${controlVar}`
    const startVal =
      node.startValueType === 'variable'
        ? `tonumber(${node.startValue || '0'})`
        : this.formatLiteralForLua(Number(node.startValue ?? 1))
    const endVal =
      node.endValueType === 'variable'
        ? `tonumber(${node.endValue || '0'})`
        : this.formatLiteralForLua(Number(node.endValue ?? 10))
    const stepVal =
      node.stepValueType === 'variable'
        ? `tonumber(${node.stepValue || '1'})`
        : this.formatLiteralForLua(Number(node.stepValue ?? 1))
    declaredVariables.add(controlVar)
    return `for ${controlVar} = ${startVal}, ${endVal}, ${stepVal} do`
  }
  private static generateTriggerServerEventCode = (
    node: NodeDefinition
  ): string => {
    const eventName = node.eventName
      ? this.formatLiteralForLua(node.eventName)
      : '"" --[[ ERROR: Missing Event Name ]]'
    const args = (node.argumentSources || [])
      .map(arg =>
        arg.type === 'variable'
          ? arg.value || 'nil'
          : this.formatLiteralForLua(arg.value)
      )
      .join(', ')
    return `TriggerServerEvent(${eventName}${args ? ', ' + args : ''})`
  }
  private static generateTriggerClientEventCode = (
    node: NodeDefinition
  ): string => {
    const eventName = node.eventName
      ? this.formatLiteralForLua(node.eventName)
      : '"" --[[ ERROR: Missing Event Name ]]'
    const target = node.useVariableForTarget
      ? `tonumber(${node.targetPlayer || '-1'})`
      : String(Number(node.targetPlayer ?? -1))
    const args = (node.argumentSources || [])
      .map(arg =>
        arg.type === 'variable'
          ? arg.value || 'nil'
          : this.formatLiteralForLua(arg.value)
      )
      .join(', ')
    return `TriggerClientEvent(${eventName}, ${target}${
      args ? ', ' + args : ''
    })`
  }
  private static generateForLoopGenericCode = (
    node: NodeDefinition,
    declaredVariables: Set<string>
  ): string => {
    const iterType = node.iterationType || 'pairs'
    const tableVar = node.tableVariable || 'nil --[[ ERROR: Missing Table ]]'
    const keyVar = node.keyVariable || '_'
    if (!keyVar || !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(keyVar))
      return `-- ERROR: Invalid key variable: ${keyVar}`
    const valueVar = node.valueVariable || '_'
    if (!valueVar || !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(valueVar))
      return `-- ERROR: Invalid value variable: ${valueVar}`
    declaredVariables.add(keyVar)
    declaredVariables.add(valueVar)
    return `for ${keyVar}, ${valueVar} in ${iterType}(${tableVar} or {}) do`
  }
  private static generateCreateTableCode = (
    node: NodeDefinition,
    declaredVariables: Set<string>,
    isInsideBlock: boolean
  ): string => {
    const varName = node.variableName?.trim()
    if (!varName || !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(varName))
      return `-- ERROR: Invalid variable name: ${varName}`
    const prefix =
      isInsideBlock && !declaredVariables.has(varName) ? 'local ' : ''
    if (isInsideBlock && !declaredVariables.has(varName))
      declaredVariables.add(varName)
    return `${prefix}${varName} = {}`
  }
  private static generateSetTableValueCode = (node: NodeDefinition): string => {
    const tableVar = node.tableVariable || 'nil --[[ ERROR: Missing Table ]]'
    const keyType = node.keyType || 'literal'
    const keyValue = node.keyValue ?? ''
    const valueType = node.valueType || 'literal'
    const valueSource = node.valueSource ?? ''
    let keyExpression: string
    if (keyType === 'variable')
      keyExpression = keyValue || 'nil --[[ ERROR: Missing Key Var ]]'
    else if (keyType === 'number_literal')
      keyExpression = String(Number(keyValue || 0))
    else keyExpression = this.formatLiteralForLua(keyValue)
    let valueExpression: string
    if (valueType === 'variable')
      valueExpression = valueSource || 'nil --[[ ERROR: Missing Value Var ]]'
    else valueExpression = this.formatLiteralForLua(valueSource)
    return `${tableVar}[${keyExpression}] = ${valueExpression}`
  }
  private static generateGetTableValueCode = (
    node: NodeDefinition,
    declaredVariables: Set<string>,
    isInsideBlock: boolean
  ): string => {
    const tableVar = node.tableVariable || 'nil --[[ ERROR: Missing Table ]]'
    const keyType = node.keyType || 'literal'
    const keyValue = node.keyValue ?? ''
    const resultVar = node.resultVariable || 'getResult'
    if (!resultVar || !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(resultVar))
      return `-- ERROR: Invalid result variable: ${resultVar}`
    const defaultValue = this.formatLiteralForLua(node.defaultValue ?? null)
    let keyExpression: string
    if (keyType === 'variable')
      keyExpression = keyValue || 'nil --[[ ERROR: Missing Key Var ]]'
    else if (keyType === 'number_literal')
      keyExpression = String(Number(keyValue || 0))
    else keyExpression = this.formatLiteralForLua(keyValue)
    const prefix =
      isInsideBlock && !declaredVariables.has(resultVar) ? 'local ' : ''
    if (isInsideBlock && !declaredVariables.has(resultVar))
      declaredVariables.add(resultVar)
    return `${prefix}${resultVar} = (${tableVar} and ${tableVar}[${keyExpression}]) or ${defaultValue}`
  }
  private static generateCallNativeCode = (
    node: NodeDefinition,
    declaredVariables: Set<string>,
    isInsideBlock: boolean
  ): string => {
    const nativeId =
      node.nativeNameOrHash?.trim() || '"" --[[ ERROR: Missing Native ]]'
    const resultVar = node.resultVariable?.trim()
    const args = (node.argumentSources || [])
      .map(arg =>
        arg.type === 'variable'
          ? arg.value || 'nil'
          : this.formatLiteralForLua(arg.value)
      )
      .join(', ')
    let prefix = ''
    if (resultVar) {
      if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(resultVar))
        return `-- ERROR: Invalid result variable: ${resultVar}`
      prefix =
        isInsideBlock && !declaredVariables.has(resultVar)
          ? `local ${resultVar} = `
          : `${resultVar} = `
      if (isInsideBlock && !declaredVariables.has(resultVar))
        declaredVariables.add(resultVar)
    }
    let invokePart: string
    if (/^0x[a-fA-F0-9]+$/i.test(nativeId))
      invokePart = `Citizen.InvokeNative(${nativeId}${args ? ', ' + args : ''})`
    else invokePart = `${nativeId}(${args})`
    return `${prefix}${invokePart}`
  }
  private static generateVector3Code = (
    node: NodeDefinition,
    declaredVariables: Set<string>,
    isInsideBlock: boolean
  ): string => {
    const resultVar = node.resultVariable || 'vectorResult'
    if (!resultVar || !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(resultVar))
      return `-- ERROR: Invalid result variable: ${resultVar}`
    const getCoord = (
      useVar: boolean | undefined,
      source: string | undefined
    ): string => {
      if (useVar) return `tonumber(${source || '0'})`
      return this.formatLiteralForLua(Number(source || 0))
    }
    const x = getCoord(node.useVariableForX, node.xSource)
    const y = getCoord(node.useVariableForY, node.ySource)
    const z = getCoord(node.useVariableForZ, node.zSource)
    const prefix =
      isInsideBlock && !declaredVariables.has(resultVar) ? 'local ' : ''
    if (isInsideBlock && !declaredVariables.has(resultVar))
      declaredVariables.add(resultVar)
    return `${prefix}${resultVar} = vector3(${x}, ${y}, ${z})`
  }
  private static generateJsonCode = (
    node: NodeDefinition,
    declaredVariables: Set<string>,
    isInsideBlock: boolean,
    indentString: string = ''
  ): string => {
    const operation = node.jsonOperation || 'encode'
    const inputVar =
      node.inputVariable || 'nil --[[ ERROR: Missing Input Var ]]'
    const resultVar = node.resultVariable || 'jsonResult'
    if (!resultVar || !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(resultVar))
      return `-- ERROR: Invalid result variable: ${resultVar}`
    const prefix =
      isInsideBlock && !declaredVariables.has(resultVar) ? 'local ' : ''
    if (isInsideBlock && !declaredVariables.has(resultVar))
      declaredVariables.add(resultVar)
    if (operation === 'encode') {
      return `${prefix}${resultVar} = json.encode(${inputVar})`
    } else {
      const pcallLine = `local success, decoded_or_error = pcall(json.decode, ${inputVar})`
      const assignLine = `if success then\n${indentString}    ${resultVar} = decoded_or_error\n${indentString}else\n${indentString}    print("ERROR: Failed to decode JSON from variable '${inputVar}':", decoded_or_error)\n${indentString}    ${resultVar} = nil -- Set to nil on error\n${indentString}end`
      if (prefix === 'local ') {
        return `local ${resultVar} = nil -- Initialize\n${pcallLine}\n${assignLine}`
      } else {
        return `${resultVar} = nil -- Initialize\n${pcallLine}\n${assignLine}`
      }
    }
  }
  private static generateInsertIntoTableCode = (
    node: NodeDefinition
  ): string => {
    const tableVar = node.tableVariable || 'nil --[[ ERROR: Missing Table ]]'
    const valueType = node.valueType || 'literal'
    const valueSource = node.valueSource ?? ''
    let valueExpression: string
    if (valueType === 'variable')
      valueExpression = valueSource || 'nil --[[ ERROR: Missing Value Var ]]'
    else valueExpression = this.formatLiteralForLua(valueSource)
    return `table.insert(${tableVar}, ${valueExpression})`
  }
  private static generateGetTableLengthCode = (
    node: NodeDefinition,
    declaredVariables: Set<string>,
    isInsideBlock: boolean
  ): string => {
    const tableVar = node.tableVariable || 'nil --[[ ERROR: Missing Table ]]'
    const resultVar = node.resultVariable || 'tableLength'
    if (!resultVar || !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(resultVar))
      return `-- ERROR: Invalid result variable: ${resultVar}`
    const prefix =
      isInsideBlock && !declaredVariables.has(resultVar) ? 'local ' : ''
    if (isInsideBlock && !declaredVariables.has(resultVar))
      declaredVariables.add(resultVar)
    return `${prefix}${resultVar} = #${tableVar}`
  }
  private static generateStringFormatCode = (
    node: NodeDefinition,
    declaredVariables: Set<string>,
    isInsideBlock: boolean
  ): string => {
    const fmtString = this.formatLiteralForLua(node.formatString || '')
    const resultVar = node.resultVariable || 'formattedString'
    if (!resultVar || !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(resultVar))
      return `-- ERROR: Invalid result variable: ${resultVar}`
    const args = (node.argumentSources || [])
      .map(arg =>
        arg.type === 'variable'
          ? arg.value || 'nil'
          : this.formatLiteralForLua(arg.value)
      )
      .join(', ')
    const prefix =
      isInsideBlock && !declaredVariables.has(resultVar) ? 'local ' : ''
    if (isInsideBlock && !declaredVariables.has(resultVar))
      declaredVariables.add(resultVar)
    return `${prefix}${resultVar} = string.format(${fmtString}${
      args ? ', ' + args : ''
    })`
  }
  private static generateStringSplitCode = (
    node: NodeDefinition,
    declaredVariables: Set<string>,
    isInsideBlock: boolean
  ): string => {
    const resultVar = node.resultVariable || 'splitResult'
    if (!resultVar || !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(resultVar))
      return `-- ERROR: Invalid result variable: ${resultVar}`
    const useVar = node.useVariableForInput ?? false
    const inputVar = node.inputStringVariable
    const inputLiteral = node.inputString
    const separator = this.formatLiteralForLua(node.separator || '')
    const limitStr = String(node.limit ?? '').trim(); // Ensure limit is string before trim
    let limitVal = 'nil'
    if (limitStr && limitStr !== '') {
      const parsedLimit = parseInt(limitStr, 10)
      if (!isNaN(parsedLimit) && parsedLimit > 0) {
        limitVal = String(parsedLimit)
      } else {
        limitVal = 'nil --[[ WARN: Invalid limit ignored ]]'
      }
    }
    let inputExpression: string
    if (useVar)
      inputExpression = inputVar || '"" --[[ ERROR: Missing Input Var ]]'
    else inputExpression = this.formatLiteralForLua(inputLiteral)
    const prefix =
      isInsideBlock && !declaredVariables.has(resultVar) ? 'local ' : ''
    if (isInsideBlock && !declaredVariables.has(resultVar))
      declaredVariables.add(resultVar)
    return `${prefix}${resultVar} = ${STRING_SPLIT_HELPER_NAME}(tostring(${inputExpression}), ${separator}, ${limitVal})`
  }
  private static generateTypeCheckCode = (
    node: NodeDefinition,
    declaredVariables: Set<string>,
    isInsideBlock: boolean
  ): string => {
    const resultVar = node.resultVariable || 'valueType'
    if (!resultVar || !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(resultVar))
      return `-- ERROR: Invalid result variable: ${resultVar}`
    const useVar = node.useVariableForInput ?? true
    const inputVar = node.inputVariable
    const inputLiteral = node.inputValue
    let valueExpression: string
    if (useVar)
      valueExpression = inputVar || 'nil --[[ ERROR: Missing Input Var ]]'
    else valueExpression = this.formatLiteralForLua(inputLiteral)
    const prefix =
      isInsideBlock && !declaredVariables.has(resultVar) ? 'local ' : ''
    if (isInsideBlock && !declaredVariables.has(resultVar))
      declaredVariables.add(resultVar)
    return `${prefix}${resultVar} = type(${valueExpression})`
  }
  private static generateToStringCode = (
    node: NodeDefinition,
    declaredVariables: Set<string>,
    isInsideBlock: boolean
  ): string => {
    const resultVar = node.resultVariable || 'stringValue'
    if (!resultVar || !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(resultVar))
      return `-- ERROR: Invalid result variable: ${resultVar}`
    const useVar = node.useVariableForInput ?? true
    const inputVar = node.inputVariable
    const inputLiteral = node.inputValue
    let valueExpression: string
    if (useVar)
      valueExpression = inputVar || 'nil --[[ ERROR: Missing Input Var ]]'
    else valueExpression = this.formatLiteralForLua(inputLiteral)
    const prefix =
      isInsideBlock && !declaredVariables.has(resultVar) ? 'local ' : ''
    if (isInsideBlock && !declaredVariables.has(resultVar))
      declaredVariables.add(resultVar)
    return `${prefix}${resultVar} = tostring(${valueExpression})`
  }
  private static generateToNumberCode = (
    node: NodeDefinition,
    declaredVariables: Set<string>,
    isInsideBlock: boolean
  ): string => {
    const resultVar = node.resultVariable || 'numberValue'
    if (!resultVar || !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(resultVar))
      return `-- ERROR: Invalid result variable: ${resultVar}`
    const useVar = node.useVariableForInput ?? true
    const inputVar = node.inputVariable
    const inputLiteral = node.inputValue
    const baseStr = String(node.base ?? '').trim(); // Ensure base is string before trim
    let baseVal = ''
    if (baseStr && baseStr !== '') {
      const parsedBase = parseInt(baseStr, 10)
      if (!isNaN(parsedBase) && parsedBase >= 2 && parsedBase <= 36) {
        baseVal = `, ${parsedBase}`
      } else {
        baseVal = ' --[[ WARN: Invalid base ignored ]]'
      }
    }
    let valueExpression: string
    if (useVar)
      valueExpression = inputVar || 'nil --[[ ERROR: Missing Input Var ]]'
    else valueExpression = this.formatLiteralForLua(inputLiteral)
    const prefix =
      isInsideBlock && !declaredVariables.has(resultVar) ? 'local ' : ''
    if (isInsideBlock && !declaredVariables.has(resultVar))
      declaredVariables.add(resultVar)
    return `${prefix}${resultVar} = tonumber(${valueExpression}${baseVal})`
  }
  private static generateStringSubstringCode = (
    node: NodeDefinition,
    declaredVariables: Set<string>,
    isInsideBlock: boolean
  ): string => {
    const resultVar = node.resultVariable || 'substringResult'
    if (!resultVar || !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(resultVar))
      return `-- ERROR: Invalid result variable: ${resultVar}`
    const useVar = node.useVariableForInput ?? false
    const inputVar = node.inputStringVariable
    const inputLiteral = node.inputString
    let inputExpression: string
    if (useVar)
      inputExpression = `tostring(${
        inputVar || '"" --[[ ERROR: Missing Input Var ]]'
      })`
    else inputExpression = this.formatLiteralForLua(inputLiteral)
    const getIndexExpr = (
      type?: 'literal' | 'variable',
      value?: string | number,
      defaultVal = '1'
    ): string => {
      if (type === 'variable') return `tonumber(${value || '0'})` // value here is var name (string)
      return String(Number(value) || defaultVal) // value here is literal (string or number from input)
    }
    const startExpr = getIndexExpr(node.startIndexType, node.startIndex, '1')
    const endExpr = getIndexExpr(node.endIndexType, node.endIndex, '')
    const prefix =
      isInsideBlock && !declaredVariables.has(resultVar) ? 'local ' : ''
    if (isInsideBlock && !declaredVariables.has(resultVar))
      declaredVariables.add(resultVar)
    return `${prefix}${resultVar} = string.sub(${inputExpression}, ${startExpr}${
      endExpr ? ', ' + endExpr : ''
    })`
  }
  private static generateStringLengthCode = (
    node: NodeDefinition,
    declaredVariables: Set<string>,
    isInsideBlock: boolean
  ): string => {
    const resultVar = node.resultVariable || 'stringLengthResult'
    if (!resultVar || !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(resultVar))
      return `-- ERROR: Invalid result variable: ${resultVar}`
    const useVar = node.useVariableForInput ?? false
    const inputVar = node.inputStringVariable
    const inputLiteral = node.inputString
    let inputExpression: string
    if (useVar)
      inputExpression = `tostring(${
        inputVar || '"" --[[ ERROR: Missing Input Var ]]'
      })`
    else inputExpression = this.formatLiteralForLua(inputLiteral)
    const prefix =
      isInsideBlock && !declaredVariables.has(resultVar) ? 'local ' : ''
    if (isInsideBlock && !declaredVariables.has(resultVar))
      declaredVariables.add(resultVar)
    return `${prefix}${resultVar} = #${inputExpression}`
  }
  private static generateStringFindCode = (
    node: NodeDefinition,
    declaredVariables: Set<string>,
    isInsideBlock: boolean
  ): string => {
    const startVar = node.resultStartIndexVar || '_'
    const endVar = node.resultEndIndexVar || '_'
    const useVarHaystack = node.useVariableForHaystack ?? false
    const haystackVar = node.haystackVariable
    const haystackLiteral = node.haystackString
    const useVarNeedle = node.useVariableForNeedle ?? false
    const needleVar = node.needleVariable
    const needleLiteral = node.needleString
    let haystackExpr: string
    if (useVarHaystack) haystackExpr = `tostring(${haystackVar || '""'})`
    else haystackExpr = this.formatLiteralForLua(haystackLiteral)
    let needleExpr: string
    if (useVarNeedle) needleExpr = `tostring(${needleVar || '""'})`
    else needleExpr = this.formatLiteralForLua(needleLiteral)
    const getIndexExpr = (
      type?: 'literal' | 'variable',
      value?: string | number
    ): string => {
      if (type === 'variable') return `tonumber(${value || '1'})` // value here is var name (string)
      return String(Number(value) || 1) // value here is literal (string or number from input)
    }
    const startIdxExpr = getIndexExpr(node.startIndexType, node.startIndex)
    const plainFindExpr = node.plainFind ? 'true' : 'false'
    const declareStart =
      startVar !== '_' && isInsideBlock && !declaredVariables.has(startVar)
    const declareEnd =
      endVar !== '_' &&
      isInsideBlock &&
      !declaredVariables.has(endVar) &&
      startVar !== endVar
    const prefix =
      (declareStart ? `local ${startVar}` : startVar) +
      (endVar !== '_' ? `, ${declareEnd ? 'local ' : ''}${endVar}` : '')
    if (declareStart) declaredVariables.add(startVar)
    if (declareEnd) declaredVariables.add(endVar)
    return `${prefix} = string.find(${haystackExpr}, ${needleExpr}, ${startIdxExpr}, ${plainFindExpr})`
  }
  private static generateStringReplaceCode = (
    node: NodeDefinition,
    declaredVariables: Set<string>,
    isInsideBlock: boolean
  ): string => {
    const resultStrVar = node.resultStringVariable || '_'
    const resultCountVar = node.resultCountVariable || '_'
    const useVarInput = node.useVariableForInput ?? false
    const inputVar = node.inputStringVariable
    const inputLiteral = node.inputString
    const useVarPattern = node.useVariableForPattern ?? false
    const patternVar = node.patternVariable
    const patternLiteral = node.patternString
    const useVarRepl = node.useVariableForReplacement ?? false
    const replVar = node.replacementVariable
    const replLiteral = node.replacementString
    let inputExpr: string
    if (useVarInput) inputExpr = `tostring(${inputVar || '""'})`
    else inputExpr = this.formatLiteralForLua(inputLiteral)
    let patternExpr: string
    if (useVarPattern) patternExpr = `tostring(${patternVar || '""'})`
    else patternExpr = this.formatLiteralForLua(patternLiteral)
    let replExpr: string
    if (useVarRepl) replExpr = replVar || '""'
    else replExpr = this.formatLiteralForLua(replLiteral)
    const getLimitExpr = (
      type?: 'literal' | 'variable',
      value?: string | number | ''
    ): string | undefined => {
      const sValue = String(value ?? '').trim();
      if (!sValue) return undefined
      if (type === 'variable') return `tonumber(${sValue || 'nil'})` // sValue is var name
      const num = parseInt(sValue, 10) // sValue is literal
      return !isNaN(num) && num > 0 ? String(num) : undefined
    }
    const limitExpr = getLimitExpr(node.limitType, node.limit)
    const declareStr =
      resultStrVar !== '_' &&
      isInsideBlock &&
      !declaredVariables.has(resultStrVar)
    const declareCount =
      resultCountVar !== '_' &&
      isInsideBlock &&
      !declaredVariables.has(resultCountVar) &&
      resultStrVar !== resultCountVar
    const prefix =
      (declareStr ? `local ${resultStrVar}` : resultStrVar) +
      (resultCountVar !== '_'
        ? `, ${declareCount ? 'local ' : ''}${resultCountVar}`
        : '')
    if (declareStr) declaredVariables.add(resultStrVar)
    if (declareCount) declaredVariables.add(resultCountVar)
    return `${prefix} = string.gsub(${inputExpr}, ${patternExpr}, ${replExpr}${
      limitExpr ? ', ' + limitExpr : ''
    })`
  }
  private static generateStringCaseCode = (
    node: NodeDefinition,
    declaredVariables: Set<string>,
    isInsideBlock: boolean
  ): string => {
    const resultVar = node.resultVariable || 'casedString'
    if (!resultVar || !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(resultVar))
      return `-- ERROR: Invalid result variable: ${resultVar}`
    const useVar = node.useVariableForInput ?? false
    const inputVar = node.inputStringVariable
    const inputLiteral = node.inputString
    const caseType = node.caseType || 'lower'
    let inputExpr: string
    if (useVar) inputExpr = `tostring(${inputVar || '""'})`
    else inputExpr = this.formatLiteralForLua(inputLiteral)
    const func = caseType === 'lower' ? 'string.lower' : 'string.upper'
    const prefix =
      isInsideBlock && !declaredVariables.has(resultVar) ? 'local ' : ''
    if (isInsideBlock && !declaredVariables.has(resultVar))
      declaredVariables.add(resultVar)
    return `${prefix}${resultVar} = ${func}(${inputExpr})`
  }
  private static generateMathAdvancedCode = (
    node: NodeDefinition,
    declaredVariables: Set<string>,
    isInsideBlock: boolean
  ): string => {
    const resultVar = node.resultVariable || 'mathAdvResult'
    if (!resultVar || !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(resultVar))
      return `-- ERROR: Invalid result variable: ${resultVar}`
    const opType = node.mathOperationType || 'floor'
    const getValueExpr = (
      type?: 'literal' | 'variable',
      value?: string | number, // value can be string or number from input
      varName?: string
    ): string => {
      if (type === 'variable') return `tonumber(${varName || '0'})`
      return this.formatLiteralForLua(Number(value || '0'))
    }
    const val1Expr = getValueExpr(
      node.value1Type,
      node.value1,
      node.value1Variable
    )
    const val2Expr = getValueExpr(
      node.value2Type,
      node.value2,
      node.value2Variable
    )
    let expr: string
    switch (opType) {
      case 'pow':
      case 'min':
      case 'max':
        expr = `math.${opType}(${val1Expr}, ${val2Expr})`
        break
      case 'random':
        const isRange =
          (node.value1 && String(node.value1).trim() !== '') ||
          (node.value2 && String(node.value2).trim() !== '')
        expr = `math.random(${isRange ? `${val1Expr}, ${val2Expr}` : ''})`
        break
      case 'floor':
      case 'ceil':
      case 'abs':
      case 'sqrt':
      default:
        expr = `math.${opType}(${val1Expr})`
        break
    }
    const prefix =
      isInsideBlock && !declaredVariables.has(resultVar) ? 'local ' : ''
    if (isInsideBlock && !declaredVariables.has(resultVar))
      declaredVariables.add(resultVar)
    return `${prefix}${resultVar} = ${expr}`
  }
  private static generateTableRemoveCode = (node: NodeDefinition): string => {
    const tableVar = node.tableVariable || 'nil --[[ ERROR: Missing Table ]]'
    const indexExpr =
      node.indexType === 'variable'
        ? `tonumber(${node.index || 'nil'})` // node.index here is var name (string)
        : node.index && String(node.index).trim() !== '' // node.index here is literal (string or number)
        ? String(Number(node.index || 0))
        : ''
    const resultVar = node.resultRemovedValueVar?.trim()
    let prefix = ''
    if (resultVar && /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(resultVar)) {
      prefix = `${resultVar} = `
    }
    return `${prefix}table.remove(${tableVar}${
      indexExpr ? ', ' + indexExpr : ''
    })`
  }
  private static generateTableSortCode = (node: NodeDefinition): string => {
    const tableVar = node.tableVariable || 'nil --[[ ERROR: Missing Table ]]'
    const sortFuncExpr =
      node.sortFunctionType === 'customVariable'
        ? node.sortFunctionVariable ||
          'nil --[[ ERROR: Missing Sort Func Var ]]'
        : ''
    return `table.sort(${tableVar}${sortFuncExpr ? ', ' + sortFuncExpr : ''})`
  }

  // formatLiteralForLua (remains same)
  private static formatLiteralForLua = (value: any): string => {
    /* ... no changes ... */ if (value === null || value === undefined)
      return 'nil'
    const type = typeof value
    switch (type) {
      case 'string':
        const escaped = value
          .replace(/\\/g, '\\\\')
          .replace(/"/g, '\\"')
          .replace(/'/g, "\\'")
          .replace(/\n/g, '\\n')
          .replace(/\r/g, '\\r')
          .replace(/\0/g, '\\0')
        return `"${escaped}"`
      case 'number':
        return String(Number(value))
      case 'boolean':
        return value ? 'true' : 'false'
      case 'object':
        if (Array.isArray(value))
          return `{ ${value.map(v => this.formatLiteralForLua(v)).join(', ')} }`
        const pairs = Object.entries(value)
          .map(([k, v]) => {
            const keyStr = /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(k)
              ? k
              : `["${k.replace(/"/g, '\\"')}"]`
            return `${keyStr} = ${this.formatLiteralForLua(v)}`
          })
          .join(', ')
        return `{ ${pairs} }`
      default:
        console.warn(
          `formatLiteralForLua: Unsupported type "${type}", converting to string.`
        )
        return `"${String(value).replace(
          /"/g,
          '\\"'
        )}" --[[ Converted from ${type} ]]`
    }
  }
}