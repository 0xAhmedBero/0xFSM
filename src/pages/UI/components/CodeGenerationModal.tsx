import React, { useState, useEffect } from 'react'
import {
  Modal,
  TextInput,
  Button,
  Group,
  Stack,
  Textarea,
  LoadingOverlay,
  Box,
  Select,
  Text,
  Divider,
  Tooltip
} from '@mantine/core'
import { notifications } from '@mantine/notifications'
import JSZip from 'jszip'
import { saveAs } from 'file-saver'
import { CodeGeneratorService } from '../../../components/CodeGeneratorService'
import { GraphData, FunctionScope, EventScope } from '../GraphContext'
import { AppFile } from '../../../App'

interface ManifestSettings {
  resourceName: string
  author: string
  version: string
  description: string
  fxVersion: string
  games: string[]
  clientScripts: string[]
  serverScripts: string[]
  sharedScripts: string[] // These arrays hold USER-DEFINED script paths
  dependencies: string // Comma-separated string
  exports: string // Comma-separated string
  uiPage: string
}


interface CodeGenerationModalProps {
  opened: boolean
  onClose: () => void
  graphsData: Record<string, GraphData> // All graphs (files, functions, events)
  filesData: AppFile[]
}

export default function CodeGenerationModal ({
  opened,
  onClose,
  graphsData,
  filesData
}: CodeGenerationModalProps) {
  const [settings, setSettings] = useState<ManifestSettings>({
    resourceName: 'my-fsm-resource',
    author: '0xFSM User',
    version: '1.0.0',
    description: 'A resource generated by 0xFSM',
    fxVersion: 'cerulean',
    games: ['gta5'],
    clientScripts: [],
    serverScripts: [], // Derived from filesData
    sharedScripts: [], // Manual entry only
    dependencies: '',
    exports: '',
    uiPage: ''
  })
  const [isLoading, setIsLoading] = useState(false)

  // Update derived script lists based on filesData
  useEffect(() => {
    const clientUserScripts = filesData
      .filter(f => f.type === 'client')
      .map(f => `client/${f.name}.lua`)
    const serverUserScripts = filesData
      .filter(f => f.type === 'server')
      .map(f => `server/${f.name}.lua`)
    // Keep manually entered shared scripts separate
    setSettings(prev => ({
      ...prev,
      clientScripts: clientUserScripts,
      serverScripts: serverUserScripts
    }))
  }, [filesData])

  // Handle form field changes
  const handleChange = (field: keyof ManifestSettings, value: any) => {
    if (field === 'games') {
      setSettings(prev => ({ ...prev, [field]: value ? [value] : [] }))
    } else {
      // Store sharedScripts, dependencies, exports directly as strings from Textarea
      // The generator service will parse them if needed
      setSettings(prev => ({ ...prev, [field]: value }))
    }
  }

  // Specific handler for the Shared Scripts textarea to update the array state used by manifest generator
  const handleSharedScriptsChange = (
    event: React.ChangeEvent<HTMLTextAreaElement>
  ) => {
    const scriptsString = event.currentTarget.value
    setSettings(prev => ({
      ...prev,
      // Update the string value for the textarea AND the array for the generator
      sharedScripts: scriptsString
        .split(',')
        .map(s => s.trim())
        .filter(s => s)
    }))
  }

  // --- Main Generation Logic ---
  const handleGenerate = async () => {
    setIsLoading(true)
    let loadingNotificationId: string | null = null

    try {
      loadingNotificationId = notifications.show({
        /* ... loading notification ... */ id: `gen-load-${Date.now()}`,
        loading: true,
        title: 'Generating Resource...',
        message: 'Processing graphs and files...',
        autoClose: false,
        withCloseButton: false
      })

      console.log('CodeGenerationModal: Starting generation...')
      const zip = new JSZip()
      const rootFolder = zip.folder(settings.resourceName)
      if (!rootFolder)
        throw new Error('ZIP Error: Failed to create root folder.')

      let generatedFileCount = 0
      const generatedFileNames: string[] = [] // Keep track of generated files for manifest

      // --- 1. Generate User Lua Script Files ---
      console.log('CodeGenerationModal: Generating user script files...')
      if (filesData && filesData.length > 0) {
        if (filesData.some(f => f.type === 'client'))
          rootFolder.folder('client')
        if (filesData.some(f => f.type === 'server'))
          rootFolder.folder('server')
        for (const fileInfo of filesData) {
          const fileName = fileInfo.name
          const fileType = fileInfo.type
          const fileKey = `${fileType}/${fileName}`
          const fileGraphData = graphsData[fileKey]
          const fileNodes = fileGraphData?.nodes || []
          const luaCode = CodeGeneratorService.generateLuaCodeForFile(
            fileName,
            fileType,
            fileNodes
          )
          rootFolder.folder(fileType)?.file(`${fileName}.lua`, luaCode)
          generatedFileCount++
        }
      }

      // --- 2. Generate Function Files ---
      console.log('CodeGenerationModal: Generating function files...')
      const functionScopes: FunctionScope[] = ['shared', 'client', 'server']
      for (const scope of functionScopes) {
        const result = CodeGeneratorService.generateFunctionFileCode(
          scope,
          graphsData
        )
        if (result && result.code) {
          // Check if code was actually generated
          const { filename, code } = result
          const [folderName, fileNameOnly] = filename.split('/')
          rootFolder.folder(folderName)?.file(fileNameOnly, code)
          generatedFileNames.push(filename) // Add to list for manifest check
          generatedFileCount++
        }
      }

      // --- 3. Generate Event Handler Files ---
      console.log('CodeGenerationModal: Generating event handler files...')
      const eventScopes: EventScope[] = ['client', 'server']
      for (const scope of eventScopes) {
        const result = CodeGeneratorService.generateEventFileCode(
          scope,
          graphsData
        )
        if (result && result.code) {
          // Check if code was actually generated
          const { filename, code } = result
          const [folderName, fileNameOnly] = filename.split('/')
          rootFolder.folder(folderName)?.file(fileNameOnly, code)
          generatedFileNames.push(filename) // Add to list for manifest check
          generatedFileCount++
        }
      }

      // --- 4. Generate fxmanifest.lua ---
      console.log('CodeGenerationModal: Generating manifest...')
      // Pass user-defined scripts AND the list of actually generated files
      const manifestSettingsForGen: ManifestSettings & {
        generatedFiles: string[]
      } = {
        ...settings,
        // Ensure arrays are passed correctly if generator expects them
        sharedScripts: settings.sharedScripts.map(s => s.trim()).filter(s => s),
        dependencies: settings.dependencies, // Pass as string
        exports: settings.exports, // Pass as string
        generatedFiles: generatedFileNames // Pass names of files created in steps 2 & 3
      }
      const manifestContent = CodeGeneratorService.generateManifestCode(
        manifestSettingsForGen,
        graphsData
      )
      rootFolder.file('fxmanifest.lua', manifestContent)
      generatedFileCount++

      // --- 5. Generate UI files placeholder ---
      if (settings.uiPage && settings.uiPage.trim()) {
        /* ... UI placeholder generation ... */
        const uiPagePath = settings.uiPage.trim()
        const pathParts = uiPagePath.split('/').filter(part => part)
        let currentFolder = rootFolder
        if (pathParts.length > 1) {
          for (let i = 0; i < pathParts.length - 1; i++) {
            currentFolder = currentFolder.folder(pathParts[i])!
          }
        }
        const uiFileName = pathParts[pathParts.length - 1] || 'ui.html'
        const uiContent = `<!-- ${uiFileName} - Generated by 0xFSM -->...`
        currentFolder.file(uiFileName, uiContent)
        generatedFileCount++
      }

      // --- 6. Create and Download Zip ---
      if (generatedFileCount === 0) throw new Error('No files were generated.')
      if (loadingNotificationId) notifications.hide(loadingNotificationId) // Hide loading before async zip

      console.log('CodeGenerationModal: Creating zip blob...')
      const zipBlob = await zip.generateAsync({
        type: 'blob',
        compression: 'DEFLATE',
        compressionOptions: { level: 6 }
      })
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-')
      saveAs(zipBlob, `${settings.resourceName}-${timestamp}.zip`)

      notifications.show({
        /* ... success notification ... */ title: 'Generation Complete!',
        message: `Generated ${generatedFileCount} file(s). Resource downloaded.`,
        color: 'green',
        autoClose: 5000,
        withCloseButton: true
      })
      onClose()
    } catch (error: any) {
      console.error('Error during code generation:', error)
      if (loadingNotificationId) notifications.hide(loadingNotificationId)
      notifications.show({
        /* ... error notification ... */ title: 'Generation Failed',
        message: `An error occurred: ${error.message || 'Unknown error'}`,
        color: 'red',
        autoClose: 8000,
        withCloseButton: true
      })
    } finally {
      setIsLoading(false)
      console.log('CodeGenerationModal: Generation process finished.')
    }
  }

  // --- Modal JSX ---
  return (
    <Modal
      opened={opened}
      onClose={onClose}
      title='Generate FiveM Resource'
      size='xl'
      centered
    >
      <Box pos='relative'>
        <LoadingOverlay
          visible={isLoading}
          overlayProps={{ radius: 'sm', blur: 2 }}
          loaderProps={{ type: 'bars' }}
        />
        <Stack gap='md'>
          <Text size='sm' c='dimmed'>
            {' '}
            Configure the resource manifest (`fxmanifest.lua`). Files for user
            scripts, functions, and events will be generated based on your
            project graphs.{' '}
          </Text>

          <Divider label='Core Settings' labelPosition='center' />
          <Group justify="center">
            {' '}
            <TextInput
              data-autofocus
              label='Resource Name'
              placeholder='my-resource'
              required
              value={settings.resourceName}
              onChange={e =>
                handleChange('resourceName', e.currentTarget.value)
              }
            />{' '}
            <TextInput
              label='Version'
              placeholder='1.0.0'
              required
              value={settings.version}
              onChange={e => handleChange('version', e.currentTarget.value)}
            />{' '}
          </Group>
          <TextInput
            label='Author'
            placeholder='Your Name'
            value={settings.author}
            onChange={e => handleChange('author', e.currentTarget.value)}
          />
          <Textarea
            label='Description'
            placeholder='A brief description...'
            value={settings.description}
            onChange={e => handleChange('description', e.currentTarget.value)}
            autosize
            minRows={2}
            maxRows={4}
          />
          <Group justify="center">
            {' '}
            <Select
              label='FXVersion'
              data={['cerulean', 'adamant', 'bodacious']}
              value={settings.fxVersion}
              onChange={value => handleChange('fxVersion', value || 'cerulean')}
              allowDeselect={false}
            />{' '}
            <Select
              label='Game Type'
              data={['gta5', 'rdr3', 'common']}
              value={settings.games[0] || 'gta5'}
              onChange={value => handleChange('games', value)}
              allowDeselect={false}
            />{' '}
          </Group>

          <Divider label='Scripts & Files' labelPosition='center' mt='sm' />
          <Textarea
            label='Client Scripts (User-defined)'
            readOnly
            value={settings.clientScripts.join('\n') || 'None'}
            autosize
            minRows={1}
            styles={{
              input: {
                backgroundColor: 'var(--mantine-color-dark-6)',
                color: 'var(--mantine-color-dimmed)',
                cursor: 'default',
                fontFamily: 'monospace'
              }
            }}
            description='Auto-detected from files created in sidebar.'
          />
          <Textarea
            label='Server Scripts (User-defined)'
            readOnly
            value={settings.serverScripts.join('\n') || 'None'}
            autosize
            minRows={1}
            styles={{
              input: {
                backgroundColor: 'var(--mantine-color-dark-6)',
                color: 'var(--mantine-color-dimmed)',
                cursor: 'default',
                fontFamily: 'monospace'
              }
            }}
            description='Auto-detected from files created in sidebar.'
          />
          <Textarea
            label='Shared Scripts (Manual Entry)'
            placeholder='e.g., shared/config.lua, @ox_lib/init.lua'
            value={settings.sharedScripts.join(', ')} // Display joined array
            onChange={handleSharedScriptsChange} // Use specific handler
            autosize
            minRows={1}
            description='Comma-separated paths relative to resource root.'
          />
          <TextInput
            label='UI Page (Optional)'
            placeholder='e.g., html/ui.html'
            value={settings.uiPage}
            onChange={e => handleChange('uiPage', e.currentTarget.value)}
            description='Path to your NUI entry point.'
          />

          <Divider label='Advanced Settings' labelPosition='center' mt='sm' />
          <Textarea
            label='Dependencies (Comma-separated)'
            placeholder='e.g., ox_lib, es_extended'
            value={settings.dependencies}
            onChange={e => handleChange('dependencies', e.currentTarget.value)}
            autosize
            minRows={1}
          />
          <Textarea
            label='Exports (Comma-separated)'
            placeholder="e.g., export 'MySharedFunc', client_export 'MyClientFunc'"
            value={settings.exports}
            onChange={e => handleChange('exports', e.currentTarget.value)}
            autosize
            minRows={1}
            description="Use full export syntax (export '...', client_export '...', server_export '...')."
          />

          <Group justify='flex-end' mt='lg'>
            <Button variant='default' onClick={onClose} disabled={isLoading}>
              {' '}
              Cancel{' '}
            </Button>
            <Button
              onClick={handleGenerate}
              disabled={isLoading || !settings.resourceName}
              loading={isLoading}
            >
              {' '}
              Generate & Download ZIP{' '}
            </Button>
          </Group>
        </Stack>
      </Box>
    </Modal>
  )
}
